# Python基础之容器类型
[TOC]

## 列表
#### 列表是一个内容可变的有序序列，其内容可以是**任意类型**，相当于有一堆对象指针。

- 列表可以实现多种数据结构，用途非常广

### 列表的创建
- 可以直接用[],也可以用list()，前者的实质是**加多**一个[],后者其实是**类型装换**（反复用不会增加列表的维数），
- 列表递推表达式 [expression for x in xxx (if condition)]

```
In[2]:list_1 = ['p'，'y','t','h','o','n']
In[3]:str_1 = 'python'
In[4]:list_2 = list(str_1)
#In[2]与In[3]In[4]等价
In[5]:list_3 = list(list_1)
In[6]:list_3
out[6]:['p'，'y','t','h','o','n']
In[7]:list_4 = [list_1]
In[8]:list_4
out[8]:[['p'，'y','t','h','o','n']]
#list_4比list_3多了一对[]
```

<br/>

### 特点
- 可以通过索引访问元素

	```
    In[9]:list_1[1]
    out[9]:['y']
	```
	索引可以为负数，**最后一个元素索引为-1**

- 可以进行切片操作

	```
    In[10]:list_1[1:5:2]#参数是[起始索引：结束索引：步长]
    out[10]:['y','h']
    ```

### 浅拷贝与深拷贝

- **切片**和**list.copy()**是浅拷贝(即若列表里还嵌套了其他列表，副本和原件同时持有对该嵌套列表的引用，修改其中之一的嵌套列表，其他的列表都会改变)
```
    In[11]:list_5 = [[1,2,3],1,2,3]
    In[12]:list_6 = list_5.copy()
    In[13]:list_7 = list_5[0:3]
    In[14]:list_5[0][1] = 4
    In[15]:list_5[1] = 2
    In[16]:list_6
    out[16]:[[1,4,3],1,2,3]

    In[17]:list_7
    out[17]:[[1,4,3],1,2]
    #修改list_5索引为1的列表，副本list_6和切片list_7中索引为0的列表同时被修改，而修改其他元素却不会
```

- 深拷贝需要用import copy模块，调用copy.deepcopy()方法就可以完全拷贝对象。

### 可迭代
- 用for x in []:实现迭代


### 列表操作
- in ：判断是否包含某元素
- [1,2] + [3,4] ：两列表元素并起来 [1,2,3,4]
- [1]\*4 ：结果是把列表的内容重复四次 [1,1,1,1]
- list\_1.reverse():逆序
- list\_1.remove(value)/list\_1.pop(index)/del list\_1[index] 均为删除元素操作
- list\_1.insert(**index**,**value**)/list\_1.append(**value**)/list\_1.extend(**list**)均为增加元素操作**注意参数不同**
- list.sort()/sorted(list) 前者**对自身排序**，返回None，后者把排序后的结果返回，**不改变本身**

## 元组

#### 元组是一个不可变的有序序列（准确的说是==引用不可变==，引用的==顺序不可变==）
- 元组内嵌套一个列表，列表本身可以改变，因为改变列表内容，**不改变**元组对该列表的引用
- 元组是作为不可变容器来使用的（比如关键字）

### 元组的创建
- 元组的符号其实是 ， 而不是(),创建一个空列表应为(,),tuple()为类型装换
### 特点(除了元素引用不可改变之外，其他和列表基本相同)

- 可以通过索引访问元素
- 可以进行切片操作

### 浅拷贝与深拷贝
- 元组本身没有拷贝的方法或函数,通过copy模块的copy.copy()方法可以实现拷贝(不过意义不大),浅拷贝而来的副本一修改，其余浅拷贝副本以及本体会同时被修改（具体针对列表而言）
- 深拷贝需要用import copy模块，调用copy.deepcopy()方法就可以完全拷贝对象。

### 可迭代

### 元组操作
- in ：判断是否包含某元素
- (1,2) + (3,4) ：两列表元素并起来 (1,2,3,4)
- (1)\*4 ：结果是把列表的内容重复四次 （1,1,1,1)

## 字典
#### 字典是一种可变容器类型，有键值对(键必须互异)
- 和列表对比，有点很明显，查找速度更快，但内存开销更高

### 字典的创建
- 用{}把键值对括起来，形如{key:value ...}，若使用dict()，则传入的参数要可以构成映射关系

```
In[18]:dict_1 = {'name':'ChokJohn','age':19,'height':180,'weigth':65}

```

### 特点

- 访问需要用键

```
In[19]:dict_1['name']
out[19]:'ChokJohn'
```


### 浅拷贝与深拷贝

- 与列表相似

### 可迭代
- 与其他不一样,dict\_1是对**键**迭代，dict\_1.items()是对**键值对**迭代，dict\_1.values()是**对值**迭代
```
In[20]: for x in dict_1:
...		pass
In[21]: for x in dict_1.items():
...		passvalue
In[22]: for x in dict_1.values():
...		pass
```

### 字典操作
- del dict\_1[key]/pop(key[, default])都是删除键值对，如果后者设置了default，当key不存在时会返回default而不会报错
- in 判断是否含有key与dict\_1.has\_key()等价
- get(key[, default]) 访问元素的另一方法，如果不存在返回default，如果不指定default则报错
- update() 用来添加或替换键值对
- fromkeys(key[, value]) 以key为键，value为值建立字典，默认value为None

## 集合
#### 集合与我们所知道的数学中的集合一样
- 利用集合的性质，我可以用集合去重

### 集合的创建
- 用{}括起来，或者set()

### 特点
- 无序
- 互异

### 可迭代
- 不过元素顺序随机

### 集合的操作
- add(value)/update(list/tuple) 添加元素,前者添加**单个元素**，后者添加**多个元素**（把序列拆开）
- remove(value)/discard(value) 删除元素，两者区别在于：当**元素不存在时**，前者会报错，后者不会
- pop() 随机弹出一个元素，空集报错
- clear() 清空

### 集合的运算
##### 设x，y是集合
- x & y # 交集
- x | y # 并集
- x - y # 差集
- x ^ y # 对称差集